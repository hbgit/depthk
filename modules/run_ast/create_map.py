#!/usr/bin/env python
from __future__ import print_function
# -*- coding: latin1 -*-

__author__ = 'Herbert OLiveira Rocha'

#Python
import sys
import os
import re
import inspect
from operator import itemgetter

# From PycParser
import pycparser.c_parser
import pycparser.c_ast
from pycparser.c_ast import *
import pycparser.c_generator


#### Gather the absolute path
sys.path.append(os.path.dirname(__file__))


# -------------------------------------------------
# Global Variables
# Portable cpp path for Windows and Linux/Unix
CPPPATH = '../utils/cpp.exe' if sys.platform == 'win32' else 'cpp'
ABS_PATH = os.path.dirname(__file__)
# -------------------------------------------------


class ParseAstPy(pycparser.c_ast.NodeVisitor):
    """
    @summary: Class to parse C program
    @todo:
        - [URGENT] how save this data mapped from a pointer -> a[i] = i;
            HIP1: VAR ; POinted
                   a  ;  a[i]
                   or
                   a[i]  ; a[i] ????????? $$$$$$$$$$$$$$$$
        - improve the expands to save the rvalues
        - SCANF function NOT supported yet :(

    """
    def __init__(self):
        self.__inputfilename = ''
        self.ast = pycparser.c_ast
        self.ast_gen = pycparser.c_generator
        self.current_funct = ''  # name of the function which definition is being parsed ('' = none)
        self.global_curr_funct = ''
        self.is_a_static_func = False
        self.has_call_func = False
        self.current_compund_func = pycparser.c_ast.Compound
        self.current_compund_FLOW = pycparser.c_ast.Compound
        self.current_flow_program_comp = [] #Compoud
        self.current_var_type = [''] #could be multiple declaration
        self.current_decl_is_None = False # If we have a decl for a struct, and NOT a decl struct VAR
        self.flag_is_a_decl = False
        self.flag_tmp_has_struct = False # This is used to identify a decl for a struct
        self.current_Id_in_init = ''
        self.current_is_ptr = False
        self.current_is_a_union = False
        self.tmp_flag_is_ptr = False
        self.tmp_flag_has_union = False
        # atributes realted to ptr index operation
        self.curr_has_operation_index_ptr = False
        self.curr_ptr_type_assig_arrRef = False
        self.curr_ptr_type_assig_binOp = False
        # This is to indentify the first Decl in a given function. 
        # This because if the the Decl if the first this Decl is on top
        # of the stack of the memory, thus by pattern this variable will be 
        # initalized with NULL. This way, we to alert the translator when it find
        # a claim if NULL comparation to skip this translation, this because the claim
        # was generated by aproximation
        self.identifier_first_decl_in_func = 1
        self.listL_of_first_decl_in_func = [] # this list we be a list of list this cuz for each var we gather some data


        self.has_ptr_assignment = False
        self.hasAssigmentInDeclPtr = False
        self.current_loc_ast = 0
        self.current_args_params_func = []
        self.is_a_input_arg_function = False
        self.has_struct_ref = False
        self.curr_field_used_by_struct_ref = pycparser.c_ast.NodeVisitor
        self.current_assignments = []

        self.list_of_flow_programs = [If,While,DoWhile,For,Switch,Case]
        self.enable_else_flow = False
        self.current_else_flow_program = []
        self.current_assig_case = ''
        self.has_assign_in_case = False

        self.flag_idenitify_global_var = False
        self.flag_return_method = False

        # Data to map the new types, i.e., typedef
        self.dictionary_of_var_types = {}
        self.dicT_type_name = ''
        self.dicT_is_pointer = False
        self.dicT_real_type = ''
        self.dicT_is_struct = False


        # Var to save the data to MAP
        self.map_line = None
        self.map_var = None
        self.map_points_to = None
        self.map_id_function = None
        self.map_is_global = None
        self.map_is_dynamic = None
        self.map_is_a_free = None
        self.map_is_a_union = None
        self.map_type_of_var = None
        self.map_is_arg_funct = 0
        self.map_number_of_vars = 10
        self.map_master_list_result = []

        #~ Only for Unit Test
        self.utest_total_num_malloc = 0
        self.utest_total_num_free = 0
        self.utest_total_num_global_var = 0
        self.utest_total_num_obj_mapped = 0 # This var is about the total objects mapped
        self.utest_lines_mapped = []


        # Options to trace generation
        self.flag_track_all = False
        self.flag_track_not_ptr = False
        self.type_name_track_all = ''




    def load2Parse(self, filename):
        """
        @summary: Load the C program and then to do the parse using pycparse
        @param filename: is the path of the C program file
        @return: NO
        """
        self.__inputfilename = filename
        # Load the input source file to build the AST, then generate the symbol table
        #
        path_cpp_args = os.path.join(os.path.dirname(__file__), "../utils/fake_libc_include")
        self.ast = pycparser.parse_file(self.__inputfilename, use_cpp=True, cpp_path=CPPPATH, cpp_args=r'-I'+path_cpp_args)
        #
        #
        #self.ast.show()
        #sys.exit()


    def resetVarsToMap(self):
        """
        @summary: Reset all variable used to gather the data to map
        @param None
        @return: None
        @warning: This method should be used before to set the variables
        """
        # Var to save the data to MAP
        self.map_line = None
        self.map_var = None
        self.map_points_to = None
        self.map_id_function = None
        self.map_is_global = None
        self.map_is_dynamic = None
        self.map_is_a_free = None
        self.map_is_a_union = None
        self.map_type_of_var = None



    def checkMapIsComplete(self, calledInLine):
        """
        @summary: Check if all data to apply the mapping is complete
        @param None
        @return: 1 if is complete and otherwise an expection is shown
        """

        map_list_2_check_vars = [self.map_line, self.map_var, self.map_points_to,
                                 self.map_id_function, self.map_is_global,
                                 self.map_is_dynamic, self.map_is_a_free,
                                 self.map_is_a_union, self.map_type_of_var, self.map_is_arg_funct]

        #print(map_list_2_check_vars)

        count_var_none = 0
        id_var = 0
        list_none = []
        #print(map_list_2_check_vars)
        for eachVar in map_list_2_check_vars:
            id_var += 1
            #print(eachVar)
            if eachVar is None:
                if id_var == 1:
                    list_none.append("__map_line__")
                elif id_var == 2:
                    list_none.append("__map_var__")
                elif id_var == 3:
                    list_none.append("__map_points_to__")
                elif id_var == 4:
                    list_none.append("__map_id_function__")
                elif id_var == 5:
                    list_none.append("__map_is_global__")
                elif id_var == 6:
                    list_none.append("__map_is_dynamic__")
                elif id_var == 7:
                    list_none.append("__map_is_a_free__")
                elif id_var == 8:
                    list_none.append("__map_is_a_union__")
                elif id_var == 9:
                    list_none.append("__map_type__")
                elif id_var == 10:
                    list_none.append("__map_is_arg_funct__")

                count_var_none += 1

        if count_var_none == 0:
            return True
        else:
            print("The data gathered is not completed!, sorry about that :( ")
            var_get = self.map_number_of_vars - count_var_none
            print("The number the data gathered was: < %s >, but is expected %s" % (var_get,self.map_number_of_vars))
            print("The incomple field are: %s" % list_none)
            print("Bug located in line: < %s >" % calledInLine)
            sys.exit()


    def setList2Map(self):
        """
        @summary: Adding in the master list the current data that has been mapping
        @param None
        @return: None
        @warning: This method only should be call before the method checkMapIsComplete
        @todo:
            - create a list using the data to map after add to master list
        """
        tmp_list_to_organize_data = []

        tmp_list_to_organize_data.append(self.map_line)
        tmp_list_to_organize_data.append(self.map_var)        
        tmp_list_to_organize_data.append(self.map_points_to)
        tmp_list_to_organize_data.append(self.map_id_function)
        tmp_list_to_organize_data.append(self.map_is_global)
        tmp_list_to_organize_data.append(self.map_is_dynamic)
        tmp_list_to_organize_data.append(self.map_is_a_free)
        tmp_list_to_organize_data.append(self.map_is_a_union)
        tmp_list_to_organize_data.append(self.map_type_of_var)
        tmp_list_to_organize_data.append(self.map_is_arg_funct)

        self.map_master_list_result.append(tmp_list_to_organize_data)




    def searchVarAssigmentInAllFunctions(self, nodeVar):
        """
        @summary: Gather the data from assigment pointer variables in global escope
        @param nodeVar: is a pycparser.c_ast.NodeVisitor
        @return: NO
        @todo:
            - at momment to print we need to get only the LOC
            - identify if is a malloc or free
        """
        for index in range(self.current_loc_ast,len(self.ast.ext)):
             if type(self.ast.ext[index]) == FuncDef:
                compund = self.ast.ext[index].body
                #print("Analyzing FUNC: %s" % self.ast.ext[index].decl.name)
                self.global_curr_funct = self.ast.ext[index].decl.name
                self.searchAssigInCompound(compund, nodeVar)


    def seachByCLibFunctions(self, stmt, nodeVar):
        
        suporttedCLibFunc = ["memcpy"]        
        
        self.resetExpandDeclVar()
        self.expand_init(stmt)
        
        nameFunction = filter(lambda func: self.current_Id_in_init in suporttedCLibFunc, suporttedCLibFunc)
        #print(nameFunction[0])        
        
        if self.has_call_func and len(nameFunction) > 0:
            #print(self.current_Id_in_init)
            #print(type(stmt))
            get_code = self.ast_gen.CGenerator().visit_FuncCall(stmt)                                       
                    
            if nodeVar.name in get_code and self.has_ptr_assignment:
                flag_IS_var = True
                #print(get_code)                
                
                if flag_IS_var:                     
                        
                    var = self.ast_gen.CGenerator().visit(stmt.args)
                    
                    lineNum = self.getNumberOfLine(stmt)
                                        
                    #reset vars to map
                    self.resetVarsToMap()
                    self.map_line = lineNum                    
                    self.map_var = nameFunction[0]
                    self.map_points_to = get_code
                    if self.flag_idenitify_global_var:
                        self.map_id_function = self.global_curr_funct
                    else:
                        self.map_id_function = self.current_funct
                    self.map_is_global = self.flag_idenitify_global_var
                    self.map_is_a_free = False
                    self.map_is_dynamic = False
                    
                    if self.current_is_a_union:
                        self.map_is_a_union = True
                    else:
                        self.map_is_a_union = False

                    self.map_type_of_var = self.type_name_track_all


                    # Finish to gather the data to map in this point
                    # Last check to add into list the data to map
                    if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):                        
                        self.setList2Map()


    def searchByFree(self, stmt, nodeVar):
        """
        @summary: Identify the call free
        @param stmt: is a item from self.current_compund_func.block_items
        @param nodeVar: is a pycparser.c_ast.NodeVisitor
        @return: NO
        """
        
        self.resetExpandDeclVar()
        self.expand_init(stmt)
        
        self.current_is_a_union = self.tmp_flag_has_union
        
        flag_replace_var = False    
        #reset vars to map
        self.resetVarsToMap()
        
        #self.has_struct_ref
        if self.has_call_func and self.current_Id_in_init == "free":
            #print("FREE %s" % self.has_ptr_assignment)
            #print(self.ast_gen.CGenerator().visit(stmt))
            #print(self.ast_gen.CGenerator().visit(stmt.args.exprs))                        
            
            for inputArg in stmt.args.exprs:
                #print("======================================= Selecting var =======================================")#COM
                #print(type(inputArg))
                
                var = ''
                rec_inputArg = '' 
                #self.visit(n.args)
                #print(self.ast_gen.CGenerator().visit(stmt.args))
                
                # >>> Pre check what is the arg type in the FuncCall
                flag_IS_var = False
                #print("----------",type(inputArg),inputArg.coord)
                               
                 
                # BinaryOp
                if(type(inputArg) == BinaryOp): 
                    
                    #print(">>>>>>>>>>>>>> BinaryOp") #COM                    
                    if inputArg.left is not None and type(inputArg.left) == ID:
                        #print(inputArg.left)
                        if inputArg.left.name == nodeVar.name and self.has_ptr_assignment:
                            flag_IS_var = True                            
                    if inputArg.right is not None and type(inputArg.right) == ID:
                        #print(inputArg.right)
                        if inputArg.left.name == nodeVar.name and self.has_ptr_assignment:
                            flag_IS_var = True

                    flag_replace_var = True
                    if self.current_funct == 'Global':
                        self.map_var = self.global_curr_funct
                    else:
                        self.map_var = self.current_funct
                    
                    #print('FLAG rep var: ',flag_replace_var)#COM
                    #print('IS: ',flag_IS_var)#COM
                    #print('VAR: ',self.map_var)#COM
                            
                                      
                elif type(inputArg) == Assignment: 
                    #print(">>>>>>>>>>>>>> Assignment") #COM                   
                    if inputArg.left is not None and type(inputArg.left) == ID:
                        #print(inputArg.lvalue)
                        if inputArg.lvalue.name == nodeVar.name and self.has_ptr_assignment:
                            flag_IS_var = True
                            
                #elif type(inputArg) == ID:
                elif type(inputArg) == StructRef:
                    #print(">>>>>>>>>>>>>> StructRef") #COM  
                    #print()
                    #print(self.ast_gen.CGenerator()._parenthesize_unless_simple(inputArg.name),"==",nodeVar.name, inputArg.coord, "???????????w")                                       
                    #print()
                    name_ref = self.ast_gen.CGenerator()._parenthesize_unless_simple(inputArg.name)
                    if name_ref == nodeVar.name and self.has_ptr_assignment:
                        #print("----------",type(inputArg),inputArg.coord) 
                        flag_IS_var = True
                        
                elif type(inputArg) == ArrayRef: #New added
                    if type(inputArg.name) == UnaryOp:
                        #print(inputArg.name.expr.name)                          
                        #print("Name: ", self.ast_gen.CGenerator()._parenthesize_unless_simple(inputArg.name))
                        name_ref = inputArg.name.expr.name
                    else:
                        name_ref = self.ast_gen.CGenerator()._parenthesize_unless_simple(inputArg.name)
                        
                    if name_ref == nodeVar.name and self.has_ptr_assignment:
                        #print("----------",type(inputArg),inputArg.coord) 
                        flag_IS_var = True
                        
                    #print("subscript: ",inputArg.subscript.name)
                
                # This is temporary
                elif type(inputArg) == Cast:                    
                    #print(">>>>>>>>>>>>>> Cast") #COM  
                    get_code = self.ast_gen.CGenerator().visit_FuncCall(stmt)                                       
                    #print(get_code)
                    #print(nodeVar.name)
                    #print(self.has_ptr_assignment)
                    
                    #print(self.current_funct)
                    
                    if nodeVar.name in get_code and self.has_ptr_assignment:
                        flag_IS_var = True
                        flag_replace_var = True
                        if self.current_funct == 'Global':
                            self.map_var = self.global_curr_funct
                        else:
                            self.map_var = self.current_funct                        
                        
                    #sys.exit()
                    
                else:  
                    #
                    #print(">>>>>>>>>>>>>> ELSE") #COM  
                    if inputArg.name == nodeVar.name and self.has_ptr_assignment:
                            #print("----------",type(inputArg),inputArg.coord) 
                            flag_IS_var = True
                    
                    
                
                if flag_IS_var:                    
                    
                    #if type(inputArg) == StructRef:
                        #var = self.ast_gen.CGenerator().visit_StructRef(inputArg)
                    #else:
                        #var = rec_inputArg
                        
                    var = self.ast_gen.CGenerator().visit(stmt.args)                    
                    
                    #print("\t \t >>> It is a Free %s" % stmt.coord) #COM
                    #print("MApping=======================================")#COM
                    lineNum = self.getNumberOfLine(stmt)
                    #print(lineNum)                    
                    
                    self.map_line = lineNum                    
                    
                    if not flag_replace_var:                    
                        self.map_var = var
                    
                    self.map_points_to = var
                    if self.flag_idenitify_global_var:
                        self.map_id_function = self.global_curr_funct
                    else:
                        self.map_id_function = self.current_funct
                    self.map_is_global = self.flag_idenitify_global_var
                    self.map_is_a_free = True
                    self.map_is_dynamic = False
                    
                    if self.current_is_a_union:
                        self.map_is_a_union = True
                    else:
                        self.map_is_a_union = False

                    self.map_type_of_var = self.type_name_track_all

                    # Finish to gather the data to map in this point
                    # Last check to add into list the data to map
                    if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):                        
                        self.setList2Map()


    def searchAssigInCompound(self, compoundStmt, nodeVar):

        if type(compoundStmt) is Compound and type(compoundStmt.block_items) is not type(None):
            
            #print(nodeVar.name,"--------------")
            #print(compoundStmt)
            #print(compoundStmt.coord)
            #print(type(compoundStmt.block_items))
            #print(compoundStmt.block_items)

            # How to run from the actual ast node -> self.current_compund_FLOW                
            for stmt in compoundStmt.block_items:
            #for stmt in self.current_compund_FLOW.block_items:
            
                #print("Actual STMT: %s" % stmt.coord)
                if type(stmt) == Assignment:
                    self.current_is_a_union = self.tmp_flag_has_union
                    #print("\t ==== %s %s" % (stmt, stmt.coord)) #COM
                    # Mapping is performed in this function
                    self.identifyAssigment(stmt, nodeVar)
                    # Reset var to ptr index
                    #self.tmp_flag_is_ptr = False

                elif type(stmt) == UnaryOp:
                    #print("\t ==== %s %s" % (stmt, stmt.coord)) #COM
                    if stmt.op == "p++" or stmt.op == "p--":
                        self.identifyAssigment(stmt, nodeVar)


                elif type(stmt) == FuncCall:
                    #print("\t ==== %s %s" % (stmt, stmt.coord))                    
                    self.searchByFree(stmt,nodeVar)
                    self.seachByCLibFunctions(stmt, nodeVar)

                # Check list of flow program conditions
                elif type(stmt) in self.list_of_flow_programs:

                    self.expand_flow_program(stmt)

                    if self.enable_else_flow:
                        # for IF
                        self.searchAssigInCompound(self.current_flow_program_comp, nodeVar)
                        # for ELSE
                        self.searchAssigInCompound(self.current_else_flow_program, nodeVar)
                    #else:
                    elif type(stmt) is Case:
                        #print("IN CASE: %s " % stmt.coord)
                        for stmt in self.current_flow_program_comp:
                            self.searchAssigInCompound(stmt, nodeVar)

                    else:
                        #print("Others")
                        self.searchAssigInCompound(self.current_flow_program_comp, nodeVar)
                     
        

        else:
            #print(nodeVar.name,"**************")
            if type(compoundStmt) == Assignment:
                #print("\t As ==== %s %s" % (stmt, stmt.coord))
                # Mapping is performed in this function
                self.identifyAssigment(compoundStmt, nodeVar)

            elif type(compoundStmt) == UnaryOp:
                if compoundStmt.op == "p++" or compoundStmt.op == "p--":
                    self.identifyAssigment(compoundStmt, nodeVar)

            elif type(compoundStmt) == FuncCall:
                #print("\t Func ==== %s %s" % (compoundStmt, compoundStmt.coord))
                self.searchByFree(compoundStmt,nodeVar)
                self.seachByCLibFunctions(compoundStmt, nodeVar)
                # How keep the seach
                
            elif type(compoundStmt) in self.list_of_flow_programs:
                #print("Is flow+++++++++++++++++++")
                if type(compoundStmt) == If: 
                    if compoundStmt.iftrue is not None: 
                        self.searchAssigInCompound(compoundStmt.iftrue, nodeVar)
                        self.searchAssigInCompound(compoundStmt.iffalse, nodeVar)
                        #print("@@@@@ "+str(self.ast_gen.CGenerator().visit_Assignment(compoundStmt.iftrue)))
                        #print(">>>>> "+str(self.ast_gen.CGenerator().visit_Assignment(compoundStmt.iffalse)))
                        
                    elif compoundStmt.iffalse is not None:       
                        self.searchAssigInCompound(compoundStmt.iffalse, nodeVar)
                        #print(">>>>> "+str(compoundStmt.iffalse.coord))
                else:
                    self.searchAssigInCompound(compoundStmt.stmt, nodeVar)
                    #print("##### "+str(compoundStmt.coord))
                


    def identifyAssigment(self, item, nodeVar):
        """
        @summary: Identify the assigments for pointers. The main focus is identify the using of malloc
        @param item: is a item from self.current_compund_func.block_items
        @param nodeVar: is a pycparser.c_ast.NodeVisitor
        @return: NO
        """

        #print(">>>>> identifyAssigment")

        # Starting gathering the data to map
        lineNum = self.getNumberOfLine(item)
        #reset vars to map
        self.resetVarsToMap()
        self.map_line = lineNum
        if self.flag_idenitify_global_var:
            self.map_id_function = self.global_curr_funct
        else:
            self.map_id_function = self.current_funct
        self.map_is_global = self.flag_idenitify_global_var
        self.map_is_a_free = False
        
        #print("identAssg is union: ",self.current_is_a_union)
        
        if self.current_is_a_union:
            self.map_is_a_union = True
        else:
            self.map_is_a_union = False

        #print(self.type_name_track_all)
        self.map_type_of_var = self.type_name_track_all

        #print("\t\t ",nodeVar.name) #COM

        # Pointer Decl with assignment
        if type(item) is Decl:
            
            #print("\t\tPointer/STRUCT Decl with assignment")

            #self.has_ptr_assignment = True

            self.map_var = nodeVar.name
            
            # We need identify if we have an assignment here $$$$$$$
                        
            if self.has_struct_ref and not self.current_is_ptr and not self.is_a_input_arg_function:
                self.map_points_to = "NULL"            
            else:
                self.map_points_to = self.map_var
            
            #print(self.current_is_ptr)
            
            
            save_actual_current_is_ptr = self.current_is_ptr
            save_actual_has_struct = self.has_struct_ref
            
            
            #print("IS a STRUCT: %s " % self.has_struct_ref)
            
            # Idenitfy if we have a FuncCall here
            self.resetExpandDeclVar()
            self.expand_init(item.init)

            # [CHANGE-DOT]
            #print(self.type_name_track_all)
            
            #print(self.has_call_func)
            
            #if decl.init is not None:
            #print("\t\t",self.current_Id_in_init)
            if self.has_call_func:  
                
                # if self.current_Id_in_init == "malloc" or \
                #    self.current_Id_in_init == "alloca":
                if self.current_Id_in_init == "malloc":
                    self.map_is_dynamic = True
                    if save_actual_has_struct:                    
                        self.map_points_to = self.map_var
                else:
                    self.map_is_dynamic = False

                #self.resetExpandDeclVar()
                #self.expand_init(item.init)

                #if self.current_Id_in_init == "malloc":
                #   self.map_is_dynamic = True
                #else:
                #    self.map_is_dynamic = False

                # Finish to gather the data to map in this point
                # Last check to add into list the data to map
                line_DEBUG = inspect.currentframe().f_back.f_lineno
                if self.checkMapIsComplete(line_DEBUG):
                    self.setList2Map()

            # This only for assignment without malloc
            elif save_actual_current_is_ptr or save_actual_has_struct:                
                self.map_is_dynamic = False
                # Finish to gather the data to map in this point
                # Last check to add into list the data to map
                line_DEBUG = inspect.currentframe().f_back.f_lineno
                if self.checkMapIsComplete(line_DEBUG):
                    self.setList2Map()


        elif type(item) is Assignment:

            # This call is to check if we have multiple assignment
            #self.tmp_flag_is_ptr = self.current_is_ptr            
            #print("\t\t >>>>> ",item.coord) #COM
            self.resetExpandDeclVar()
            self.expand_init(item)

            # The first, but we have this list because we can find a multiple assignment
            self.current_assignments.append(item)
            #now we confirm if we have have a multiple assignment
            #if len(self.current_assignments) > 1:
            #print(len(self.current_assignments))


            for each_assign in self.current_assignments:

                #print("&&&&&&&&&&&&&&&&&&",self.curr_has_operation_index_ptr)

                # In this case the identification is perfomed
                # analyzing the lvalue. Here we want to know
                # if the left of the assignment is a struct
                # and if the right side is used malloc
                #if type(item.lvalue) is UnaryOp:
                self.resetExpandDeclVar()
                #print("EACH:::: ",self.expand_init(each_assign), type(each_assign), each_assign.coord)
                self.expand_init(each_assign)
                #print(self.ast_gen.CGenerator().visit_FileAST(each_assign)) #COM


                if self.has_struct_ref:                    

                    # If the assignment is a StructRef
                    # we need identify the field and if the
                    # assignment is using a malloc function
                    # ex: pdata->lo = malloc(16);
                    #     *(pdata->high) = globla_A;
                    #     *p = &a;

                    #print("--------------- StructRef ------------------")
                    #print("\t\tSTRUCT REF.ID Assignment: %s" % item.coord) #COM
                    #print("\t\t name: ",self.current_Id_in_init) #COM
                    if self.current_Id_in_init == nodeVar.name:
                        #print("\t\t MATCH STRUCT REF.ID") #COM
                        
                        #Decl struct
                        # TODO: replace var points to  by NULL in this case $$$$$$$$$$$$$$$$$$$$$$$$$$$$                        
                        
                        get_struct_ref = self.ast_gen.CGenerator().visit(each_assign.lvalue)                      
                        self.map_var = get_struct_ref  
                        
                        #print()
                        
                        #print(nodeVar.coord)
                        #if (self.flag_idenitify_global_var or self.is_a_static_func) and not self.is_a_input_arg_function:
                            #print("\t @@@@@@@@ VAR: %s " % self.current_Id_in_init)
                            #self.map_points_to = "NULL"
                        #else:
                            #print("\t ######## VAR: %s " % self.current_Id_in_init)
                            #self.map_points_to = get_struct_ref
                            
                        # [CHANGE-DOT]
                        if self.flag_track_all and self.flag_track_not_ptr:
                            self.map_points_to = "NULL"
                        else:
                            self.map_points_to = get_struct_ref
                            
                        #print("FILD: %s " % self.curr_field_used_by_struct_ref.name)
                        
                        #print(self.ast_gen.CGenerator().visit_Assignment(each_assign))
                        #print("================ ",self.ast_gen.CGenerator().visit_StructRef(each_assign.lvalue))
                        #print(each_assign.rvalue)
                        #print()
                        
                        #get_struct_ref = self.ast_gen.CGenerator().visit_StructRef(each_assign.lvalue)
                        
                        #print(self.ast_gen.CGenerator().visit(each_assign.lvalue))
                        #print(self.ast_gen.CGenerator().visit_StructRef(each_assign.lvalue))
                        
                        #print(self.current_Id_in_init)
                        
                        # OLD WAY self.map_var = self.current_Id_in_init+"->"+self.curr_field_used_by_struct_ref.name
                        
                        self.resetExpandDeclVar()                        
                        self.expand_init(each_assign.rvalue)

                        self.has_ptr_assignment = True

                        if self.has_call_func:                            
                            if self.current_Id_in_init == "malloc":
                                self.map_is_dynamic = True
                            else:
                                self.map_is_dynamic = False

                        #*(pdata->high) = globla_A;
                        else:
                            self.map_is_dynamic = False

                        # [CHANGE-DOT]
                        #print(self.type_name_track_all)

                        # Finish to gather the data to map in this point
                        # Last check to add into list the data to map
                        if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):
                            self.setList2Map()


                else:
                    #print("@@@ %s == %s -- %s " % (self.current_Id_in_init, nodeVar.name, nodeVar.coord))

                    if self.current_Id_in_init == nodeVar.name:
                        #print("OKAY")
                        name_var = ''                        
                                                
                        flag_is_struture_type = False

                        #print(type(each_assign.lvalue))

                        flag_deref_symb = False
                        if type(each_assign.lvalue) == UnaryOp:
                            if each_assign.lvalue.op == "*":
                                flag_deref_symb = True

                        
                        if type(nodeVar.type.type) == Struct:
                            flag_is_struture_type = True
                        

                        # identify if the any ptr var has index operation
                        # self.curr_has_operation_index_ptr
                        
                        #print(str(self.tmp_flag_is_ptr)+" and "+str(self.curr_has_operation_index_ptr))
                        
                        if self.tmp_flag_is_ptr and self.curr_has_operation_index_ptr:                            
                            # idenitfy the type of operation
                            if self.curr_ptr_type_assig_arrRef:
                                name_var = self.ast_gen.CGenerator().visit_ArrayRef(each_assign.lvalue)
                            elif self.curr_ptr_type_assig_binOp:                                
                                #print(">>>", each_assign.lvalue.coord) #COM
                                name_var = each_assign.lvalue.op + "(" + self.ast_gen.CGenerator().visit_BinaryOp(each_assign.lvalue.expr) + ")"

                            self.map_var = name_var

                        else:
                            #print("ELSE")
                            self.map_var = nodeVar.name

                        #print(self.map_var, nodeVar.name)

                        # fix reset possibilities
                        #self.curr_has_operation_index_ptr = False


                        self.resetExpandDeclVar()
                        self.expand_init(each_assign.rvalue)

                        self.has_ptr_assignment = True

                        if self.has_call_func:
                            if self.current_Id_in_init == "malloc":
                                self.map_is_dynamic = True
                            else:
                                self.map_is_dynamic = False

                        # When is only an assignment
                        else:
                            self.map_is_dynamic = False
                            
                        
                        # [CHANGE-DOT]
                        if flag_is_struture_type:
                            self.map_points_to = "NULL"
                        elif self.flag_track_all and self.flag_track_not_ptr:
                            self.map_points_to = "NULL"
                        elif flag_deref_symb:
                            self.map_points_to = "NULL"
                        else:
                            self.map_points_to = self.map_var

                        # [CHANGE-DOT]
                        #print(self.type_name_track_all)

                        # Finish to gather the data to map in this point
                        # Last check to add into list the data to map
                        if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):
                            self.setList2Map()

                self.curr_has_operation_index_ptr = False

        elif type(item) is UnaryOp:

            # Checking if the var is the actual var that we have tracking
            var = ''
            if type(item.expr) == ID:
                var = item.expr.name
            elif type(item.expr) == ArrayRef:
                var = item.expr.name.name

            #print("\t",var," == ", nodeVar.name)

            if var == nodeVar.name:

                if type(item.expr) == ArrayRef:
                    var = self.ast_gen.CGenerator().visit_ArrayRef(item.expr)
                self.map_var = var
                self.map_points_to = var

                lineNum = self.getNumberOfLine(item)
                self.map_line = lineNum

                if self.flag_idenitify_global_var:
                    self.map_id_function = self.global_curr_funct
                else:
                    self.map_id_function = self.current_funct
                self.map_is_global = self.flag_idenitify_global_var

                self.map_is_a_free = False
                self.map_is_dynamic = False

                if self.current_is_a_union:
                    self.map_is_a_union = True
                else:
                    self.map_is_a_union = False

                self.map_type_of_var = self.type_name_track_all

                # Finish to gather the data to map in this point
                # Last check to add into list the data to map
                if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):
                    self.setList2Map()





    def checkVarType(self):
        """
        @summary: Check if the current var type is a typedef and if this var is a pointer
        @param None
        @return: True if the var is a pointer, False otherwise
        """
        # e.g., static unsigned long <int> <- this item
        


        if self.flag_is_a_decl and not self.flag_tmp_has_struct:

            get_only_type = self.current_var_type[-1]
            #print("=============================>", get_only_type)          

            # Working here $$$$$$$$$$$$$$ FAIKE POINTER
            
            # [TODO] improve this to do using recursion
            if get_only_type in self.dictionary_of_var_types:                
                # Pointer
                #print(self.dictionary_of_var_types.get(get_only_type)[1])                
                #print(self.dictionary_of_var_types.get(get_only_type)) 
                
                # Check more one time if the current type is a type defined in the program
                for definedType in self.dictionary_of_var_types.get(get_only_type)[0]:
                    if definedType in self.dictionary_of_var_types:
                        #print(self.dictionary_of_var_types.get(definedType))
                        get_only_type = definedType
                        #print(self.dictionary_of_var_types.get(get_only_type)[1])
                
                
                
                # Check if is a pointer and is a struct 
                if self.dictionary_of_var_types.get(get_only_type)[1] and self.dictionary_of_var_types.get(get_only_type)[2]:
                    self.has_struct_ref = True 
                    self.current_is_ptr = True # New add
                    return True
                
                # Check if is a NOT pointer and is a struct 
                # New cond added
                elif not self.dictionary_of_var_types.get(get_only_type)[1] and self.dictionary_of_var_types.get(get_only_type)[2]:                                        
                    self.has_struct_ref = True
                    self.current_is_ptr = False # New add
                    return True
                
                # Check if is a pointer and is NOT a struct 
                elif self.dictionary_of_var_types.get(get_only_type)[1] and not self.dictionary_of_var_types.get(get_only_type)[2]:                                        
                    #print("Here........................")
                    self.has_struct_ref = False # New add
                    self.current_is_ptr = True # New add
                    return True                
                
                else:
                    return False
                    
                    
        #elif self.flag_is_a_decl and self.flag_tmp_has_struct:
            # It is only if we have a decl for a struct, e.g., struct name *ptr;
        #    return True
        else:
            return False


        #for key, value in self.dictionary_of_var_types.items():
            #print("%s - %s" % (key, value))


    def sort_type_names_decl(self, _list_type):
        flag_unsigned_or_signed = False
        pos_list_to_unsigned_or_signed = -1 # the var is not signed
        flag_long_or_short = False
        pos_list_to_long_or_short = []
        all_index_used = []

        #searching by unsigned or signed
        for index, name in enumerate(_list_type):
            if name == "unsigned" or name == "signed":
                pos_list_to_unsigned_or_signed = index

        #searching by long or short
        for index, name in enumerate(_list_type):
            if name == "long" or name == "short":
                pos_list_to_long_or_short.append(index)

        # set the sort of the types accordng our style
        types_shorted = []
        # 1st sinal
        if pos_list_to_unsigned_or_signed > -1:
            all_index_used.append(pos_list_to_unsigned_or_signed)
            types_shorted.append(_list_type[pos_list_to_unsigned_or_signed])
        # 2st size
        if len(pos_list_to_long_or_short) > 0:
            for pos in pos_list_to_long_or_short:
                all_index_used.append(pos)
                types_shorted.append(_list_type[pos])

        # 3st the type
        all_index = range(len(_list_type))
        index_not_used = list(set(all_index)-set(all_index_used))
        for pos in index_not_used:
            types_shorted.append(_list_type[pos])


        return types_shorted





    def get_current_type(self, _list_type):
        #print(_list_type)
        str_type = ' '.join(_list_type)
        if str_type in self.dictionary_of_var_types:
            # Sorting the types by our style if necessary
            if len(self.dictionary_of_var_types[str_type][0]) > 1:
                namessorted = self.sort_type_names_decl(self.dictionary_of_var_types[str_type][0])
                return ' '.join(namessorted)
            else:
                #print("Here", self.dictionary_of_var_types[str_type])
                # Checking when the typedef is "" blank
                if self.dictionary_of_var_types[str_type][0] == '':
                    return ' '.join(_list_type)
                else:
                    return ' '.join(self.dictionary_of_var_types[str_type][0])
        else:
            if len(_list_type) > 1:
                namessorted = self.sort_type_names_decl(_list_type)
                return ' '.join(namessorted)
            else:
                return str_type




    def getDataFromVar(self, nodeVar, enableSearchAllFunc):
        """
        @summary: Gather the data from variables
        @param nodeVar: pycparser.c_ast.NodeVisitor
        @param enableSearchAllFunc: an integer to enable the search in All functions
        @return: NO
        """

        self.reset_track_flags()

        #identify when is a pointer and when has a pointer in a struct
        # eg., static void free_data(TData data)

        # [DONE] Mapping OKAY HERE :)
        # This is necessary to identify decl struct
        
        if type(nodeVar) is Decl:
            self.flag_is_a_decl = True            
        else:                       
            self.flag_is_a_decl = False

        #print("A STRUCT: %s" % self.has_struct_ref)
        self.resetExpandDeclVar()
        #print(self.expand_decl(nodeVar))
        self.expand_decl(nodeVar)
        #print(self.expand_decl(nodeVar))
        
        self.tmp_flag_has_union = self.current_is_a_union        
        
        #print("Is a Union: ", self.current_is_a_union)
        #print(self.expand_decl(nodeVar))
        #print("expand --- STRUCT: %s" % self.has_struct_ref)

        if not self.current_decl_is_None and type(nodeVar) is not Typename:         
            
            
            # Here we check again if the VAR is a Ptr, this because the VAR type could be defined by a typedef
            # print("Analyzing: ",nodeVar.coord)
            #
            #print("IS pointer B: ",self.current_is_ptr )
            # print("TypeCheck: ", self.checkVarType() )
            # print("STRUCT: %s" % self.has_struct_ref )
            # print("STRUCT flag: %s" % self.flag_tmp_has_struct )
            
            # COMMENT last modified
            #if self.checkVarType() and not self.current_is_ptr:
            #    self.current_is_ptr = True
            
            # New this we can isolate what is pointer and what is struct
            if not self.current_is_ptr:
                self.checkVarType()


                            
            # print("------- After call -------")
            #print("IS pointer: ",self.current_is_ptr)
            #print("IS STRUCT: %s" % self.has_struct_ref)
            #print("STRUCT flag: %s" % self.flag_tmp_has_struct)
            
            
            

            #identify if is a ptr
            if self.current_is_ptr or self.has_struct_ref:
                # Searching this variable in the program

                #[CHANGE-DOT]
                self.type_name_track_all = self.get_current_type(self.current_var_type)
                #self.map_type_of_var = self.type_name_track_all
                #print(">>>>>>>>>>>>>>", self.map_type_of_var)

                if self.current_is_ptr:
                    # First of all, save the identifier PTR to execute the next steps
                    self.tmp_flag_is_ptr = True

                #print("\t\tSearching by the PTR: %s" % nodeVar.name)
                
                # It is necessary identify if is a input arg from function
                if self.is_a_input_arg_function:
                    #print("ARG FUNC in ",nodeVar.coord)

                    #[CHANGE-DOT]
                    #self.type_name_track_all = self.get_current_type(self.current_var_type)
                    #print(self.type_name_track_all)


                    self.has_ptr_assignment = True
                    lineNum = self.getNumberOfLine(nodeVar)
                    #reset vars to map
                    self.resetVarsToMap()

                    self.map_type_of_var = self.type_name_track_all

                    self.map_line = lineNum                    
                    self.map_var = nodeVar.name                    
                    if self.has_struct_ref and not self.current_is_ptr:
                        self.map_points_to = "NULL"
                    else:                        
                        self.map_points_to = self.map_var
                    self.map_id_function = self.current_funct
                    self.map_is_global = self.flag_idenitify_global_var
                    self.map_is_a_free = False
                    self.map_is_dynamic = False
                    
                    if self.current_is_a_union:
                        self.map_is_a_union = True
                    else:
                        self.map_is_a_union = False

                    #[CHANGE-DOT]
                    #self.type_name_track_all = self.get_current_type(self.current_var_type)
                    #self.map_type_of_var = self.type_name_track_all
                    

                    # Last check to add into list the data to map
                    if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):
                        self.setList2Map()


                # Is for this case:
                # int main() {
                #     TData data;
                elif not self.hasAssigmentInDeclPtr and self.has_struct_ref:

                    lineNum = self.getNumberOfLine(nodeVar)
                    #reset vars to map
                    self.resetVarsToMap()

                    self.map_type_of_var = self.type_name_track_all

                    self.map_line = lineNum
                    self.map_var = nodeVar.name
                    self.map_points_to = "NULL"
                    self.map_id_function = self.current_funct
                    self.map_is_global = self.flag_idenitify_global_var
                    self.map_is_a_free = False
                    self.map_is_dynamic = False

                    if self.current_is_a_union:
                        self.map_is_a_union = True
                    else:
                        self.map_is_a_union = False


                    # Last check to add into list the data to map
                    if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):
                        self.setList2Map()

                # Identify it has a Decl with assignment to ptr
                elif self.hasAssigmentInDeclPtr or self.has_struct_ref:                    
                    #sprint("<<< ",self.hasAssigmentInDeclPtr)
                    #print("\t\tPTR or STRUCT assig in: %s" % nodeVar.coord) #COM
                    self.has_ptr_assignment = True
                    self.identifyAssigment(nodeVar,nodeVar)


                # Identify if the search about assigments is in all function or not
                if enableSearchAllFunc:
                    #Flag to identify that this variable is global
                    #print("Searching by: %s" % nodeVar.name)
                    self.current_is_a_union = self.tmp_flag_has_union
                    #print("T Is a Union: ", self.current_is_a_union)
                    self.searchVarAssigmentInAllFunctions(nodeVar)
                else:
                    #Flag to identify that this variable is NOT global
                    self.flag_idenitify_global_var = False
                    self.has_ptr_assignment = True
                    self.current_is_a_union = self.tmp_flag_has_union
                    #print("Keep -> searching by %s %s" % (nodeVar.name, nodeVar.coord))
                    #print("Keep Is a Union: ", self.current_is_a_union)
                    #print(self.has_ptr_assignment)
                    #self.searchAssigInCompound(self.current_compund_func, nodeVar)
                    #self.current_compund_FLOW
                    #self.searchAssigInCompound(self.current_compund_func, nodeVar)
                    
                    #print("START: ",self.current_compund_FLOW," in ",self.current_compund_FLOW.coord)
                    self.searchAssigInCompound(self.current_compund_FLOW, nodeVar)

                # Reset flag
                self.has_ptr_assignment = False
                self.tmp_flag_is_ptr = False
                self.tmp_flag_has_union = False


            # ************* It is NOT a PTR ********************
            else:
                #print("Searching by Decl at %s" % nodeVar.coord)
                #print("NOT POINT Searching by Decl that is %s" % nodeVar.name)
                lineNum = self.getNumberOfLine(nodeVar)
                #reset vars to map

                self.resetVarsToMap()

                self.map_line = lineNum
                self.map_var = nodeVar.name                
                self.map_points_to = "NULL"                            
                self.map_id_function = self.current_funct
                self.map_is_global = self.flag_idenitify_global_var
                self.map_is_a_free = False
                self.map_is_dynamic = False
                
                if self.current_is_a_union:
                    self.map_is_a_union = True
                else:
                    self.map_is_a_union = False

                #[CHANGE-DOT]
                self.type_name_track_all = self.get_current_type(self.current_var_type)
                #print(">>>>>>>>>>>>>>>>>", self.type_name_track_all)
                self.map_type_of_var = self.type_name_track_all

                # Last check to add into list the data to map
                if self.checkMapIsComplete(inspect.currentframe().f_back.f_lineno):
                    self.setList2Map()

                if self.flag_track_all:
                    self.flag_track_not_ptr = True
                    # DOING: Map all assignments
                    # Identify if the search about assigments is in all function or not
                    if enableSearchAllFunc:
                        #print("Searching by: %s" % nodeVar.name)
                        self.searchVarAssigmentInAllFunctions(nodeVar)
                    else:
                        #Flag to identify that this variable is NOT global
                        self.flag_idenitify_global_var = False
                        self.has_ptr_assignment = True
                        self.searchAssigInCompound(self.current_compund_FLOW, nodeVar)

            #print()


    @staticmethod
    def getNumberOfLine(nodeVar):
        txt = str(nodeVar.coord)
        matchNumLine = re.search(r'(.[^:]+)$', txt)
        if matchNumLine:
            onlyNumber = matchNumLine.group(1).replace(":","")
            return int(onlyNumber)


    def mapGlobalVars(self):
        """
        @summary: Gather the global variables and identify its declaration
        @return: NO
        """
        self.flag_idenitify_global_var = True
        for index in range(0,len(self.ast.ext)):
            
            if type(self.ast.ext[index]) == Decl and not type(self.ast.ext[index].type) == FuncDecl:
                
                self.current_loc_ast = index
                self.current_funct = 'Global'
                self.getDataFromVar(self.ast.ext[index],1)

        #reset AST location
        self.current_loc_ast = 0



    @staticmethod
    def searchDeclInStmts(compoundFlow, currentAstLoc):
        """
        @summary: Searhing by Decl in a specific flow
        @return: NO
        """
        for stmt in compoundFlow.block_items:
            currentAstLoc += 1
            if type(stmt) == Decl:
                # The mapping should be from HERE !!!!!!!!!!!!!
                #self.current_loc_ast = index
                #self.getDataFromVar(self.ast.ext[index],1)
                print("%s %s" % (stmt,currentAstLoc))


    def searchDeclInFlowProgram(self, flowProgramCond, currentAstLoc):
        """
        @summary: The function searhing by flow program conditions from one specific flow
        @return: The Decl and the AST location
        @todo:
            - review is is really necessary the VAR currentAstLoc ???
        """
        
        # How knows where I come from, the compound? $$$$$$$$$$$$$$$$4

        save_next_flow_program = ''
        #print(type(flowProgramCond),save_next_flow_program)     


        if type(flowProgramCond) is Compound:
            #print("**********************************************")            
            #print(">>>>>", flowProgramCond.block_items)
            if not flowProgramCond.block_items is None:
                for stmt in flowProgramCond.block_items:

                    if type(stmt) == Decl:
                        #print("Searching by Decl in FLOW: %s <> %s" % (stmt.name, stmt.coord))
                        #print()
                        #print(self.ast_gen.CGenerator().visit(stmt))
                        #self.current_loc_ast = index

                        self.getDataFromVar(stmt,0)

                    elif type(stmt) in self.list_of_flow_programs:
                        save_next_flow_program = stmt
                        #self.current_compund_FLOW = stmt
                        self.searchDeclInFlowProgram(save_next_flow_program, currentAstLoc)
                        # BUG we DO NOT run the flow program
                        #print("======== %s" % save_next_flow_program)
                    
                    



        elif (type(flowProgramCond) or save_next_flow_program) in self.list_of_flow_programs:
            
            #self.current_compund_FLOW = flowProgramCond
            
            self.expand_flow_program(flowProgramCond)

            if self.enable_else_flow:                
                # for IF                
                self.searchDeclInFlowProgram(self.current_flow_program_comp, currentAstLoc)
                # for ELSE                
                self.searchDeclInFlowProgram(self.current_else_flow_program, currentAstLoc)

            elif type(flowProgramCond) is Case:                
                self.searchDeclInFlowProgram(self.current_assig_case, currentAstLoc)

            else: 
                #print(flowProgramCond.coord)                 
                self.searchDeclInFlowProgram(self.current_flow_program_comp, currentAstLoc)



    def mapEachFunction(self):
        """
        @summary: Gather the data from each Function. How is perfomed this mapping:
                [DONE] (1) Mapping input args from function and all its assigments
                [DONE] (2) Mapping Decl outside compound and all its assigments
                [DONE] (3) Searching Decl in each compound and then Mapping
        @return: NO
        """
        self.flag_idenitify_global_var = False
        for index in range(0,len(self.ast.ext)):

             if type(self.ast.ext[index]) == FuncDef:
                #reset
                self.map_is_arg_funct = 0

                #get the name of the function
                #print(">>> Function: ",end="")
                #print(self.ast.ext[index].decl.name)
                #print(self.ast_gen.CGenerator().visit_FuncDef(self.ast.ext[index]))
                #print(self.ast_gen.CGenerator().visit(self.ast.ext[index].decl))
                
                if len(self.ast.ext[index].decl.storage) > 0:
                    if "static" in self.ast.ext[index].decl.storage:
                        self.is_a_static_func = True
                else:
                    self.is_a_static_func = False
                
                self.current_funct = self.ast.ext[index].decl.name

                #set current body function, i.e., the escope of the function
                self.current_compund_func = self.ast.ext[index].body

                self.resetExpandDeclVar()
                self.expand_decl(self.ast.ext[index].decl.type)


                #get all args from the function
                # (1) Mapping input args from function and all its assigments
                if len(self.current_args_params_func) > 0:
                    #print("--------------- Input Args: ---------------")
                    self.is_a_input_arg_function = True
                    self.map_is_arg_funct = 1
                    for eachArg in self.current_args_params_func:
                        #print("ARG FUNC: ",eachArg.name, "at ",eachArg.coord)
                        self.current_compund_FLOW = self.current_compund_func
                        self.getDataFromVar(eachArg,0)
                    self.is_a_input_arg_function = False
                    #print("---------------End Input Args---------------")
                    #print("")

                #reset
                self.map_is_arg_funct = 0

                #print("--------------- Decl and Pointer Assigments ---------------")
                # get Decl and identify if is a pointer
                # WARNNING: This Compound is the function!!!
                # Keeping the track in the AST
                save_current_ast_loc = index
                #print(self.current_compund_func.coord,"-----")
                if self.current_compund_func.block_items is not None:
                    
                    # reset counter to identify the first Decl in Func
                    self.identifier_first_decl_in_func = 1
                    
                    for item in self.current_compund_func.block_items:                        
                        #print(self.ast_gen.CGenerator().visit(item))
                        #print(type(item))
                        save_current_ast_loc += 1
                        # (2) Mapping Decl outside compound and all its assigments
                        if type(item) == Decl:
                            
                            #self.current_loc_ast = index # BUG
                            #print("---------------------------------------------")
                            #print()
                            #print("Searching by Decl: %s <> %s | Count Decl = %s" % (item.name, item.coord,self.identifier_first_decl_in_func))
                            #print("Searching by Decl: %s <> %s" % (item.name, item.coord))
                            
                            
                            # [TOP on STACK] Here we consider all type for first Decl in Function main, 
                            # Then we save this data in a list
                            if self.identifier_first_decl_in_func == 1 and\
                               self.current_funct == 'main': 
                                #print("First Decl in Func: %s <> %s" % (nodeVar.name, nodeVar.coord))
                                self.listL_of_first_decl_in_func.append(self.getNumberOfLine(item))
                                self.listL_of_first_decl_in_func.append(item.name)
                                #print()
                            
                            
                            # FROM here try to implement the run by the ast index
                            self.current_compund_FLOW = self.current_compund_func                            
                            #print("PRE start FUNC::::::: ",self.current_compund_FLOW)
                            self.getDataFromVar(item,0)
                            
                            self.identifier_first_decl_in_func += 1 

                        # (3) Searching Decl in each compound and then Mapping
                        elif type(item) in self.list_of_flow_programs:                            
                            #print("Searching in flow programs: ", item, item.coord)
                            # The function searhing by a Decl and return is AST location and Decl      
                            #print()                                                  
                            #print("----------------------- FLOW in ", item.coord,"---------------------")
                            self.current_compund_FLOW = item
                            self.searchDeclInFlowProgram(item, save_current_ast_loc)                            

                #print("--------------- End Decl and Pointer Assigments -----------")
                #print("")




        #reset AST location
        self.current_loc_ast = 0
        self.current_compund_func = pycparser.c_ast.Compound




    def resetExpandDeclVar(self):
        """
        @summary: Reset the variable used in function expand_decl
        @return: NO
        """
        self.curr_field_used_by_struct_ref = ''
        self.curr_ptr_type_assig_binOp = False
        self.curr_has_operation_index_ptr = False
        
        self.current_args_params_func = []
        self.current_var_type = []
        self.current_Id_in_init = ''
        self.current_args_params_func = []
        self.current_is_ptr = False 
        self.current_is_a_union = False       
        self.current_decl_is_None = False        
        self.current_assignments = []
        
        self.hasAssigmentInDeclPtr = False
        self.has_call_func = False
        self.has_struct_ref = False
        
        self.flag_tmp_has_struct = False


    def reset_track_flags(self):
        self.flag_track_not_ptr = False
        
        
        
        



    def expand_decl(self, decl):
        """
        @summary: Converts the declaration into a nested list
        @param decl: pycparser.c_ast.*
        @return: NO
        @todo:
            - Create a way to avoid function declaration, this beacuse
              we do not care about this kind of declaration
        @warning: It is very advice that you call the function resetSpecificVariables reset before you call
                this function
                self.current_is_a_union
        """
        typ = type(decl)

        if typ == TypeDecl:
            #for i in decl.type.names:
            #    print(i)
            return ['TypeDecl', self.expand_decl(decl.type)]
        elif typ == IdentifierType:
            self.current_var_type = decl.names
            # Check is this type is a pointer or struture
            return ['IdentifierType', decl.names]
        elif typ == ID:
            return ['ID', decl.name]
        elif typ == FuncDef:
            return ['FuncDef', decl.coord, self.expand_decl(decl.type)]
        elif typ in [Struct, Union]:
            # Identify if has a Union
            if typ == Union:
                self.current_is_a_union = True


            self.flag_tmp_has_struct = True
            self.has_struct_ref = True
            # WARNNING: CHECKOUT REGRESSION TESTS
            #decls = [self.expand_decl(d) for d in decl.decls or []]
            #return [typ.__name__, decl.name, decls]
            return [typ.__name__, decl.name]

        else:
            #t = decl.children()
            #for k,j in t:
            #    print(")))) %s - %s" % (k,j))
            #print(typ, decl.type)


            nested = self.expand_decl(decl.type)

            if typ == Decl:

                # Identify is we need to map this
                if decl.name is None:
                    self.current_decl_is_None = True

                if decl.quals:
                    if decl.init is not None:
                        self.hasAssigmentInDeclPtr = True                        
                        #rec_init = self.expand_init(decl.init)
                        #return ['Decl', decl.quals, decl.name, rec_init, nested]
                        # This cuz the init will be check in self.identifyAssigment
                        return ['Decl', decl.quals, decl.name, decl.init, nested] # New
                    else:
                        self.hasAssigmentInDeclPtr = False
                        return ['Decl', decl.quals, decl.name, nested]
                else:                    
                    if decl.init is not None:                        
                        self.hasAssigmentInDeclPtr = True
                        #rec_init = self.expand_init(decl.init)
                        #return ['Decl', decl.name, rec_init, nested]
                        # This cuz the init will be check in self.identifyAssigment
                        return ['Decl', decl.name, decl.init, nested] # New
                    else:
                        self.hasAssigmentInDeclPtr = False
                        return ['Decl', decl.name, nested]
            elif typ == Typename: # for function parameters
                if decl.quals:
                    return ['Typename', decl.quals, nested]
                else:
                    return ['Typename', nested]
            elif typ == ArrayDecl:
                if type(decl.dim) == UnaryOp:
                    #dimval = decl.dim.value if decl.dim else ''
                    return ['ArrayDecl', decl.dim.expr, decl.dim_quals, nested]
                else:                
                    dimval = decl.dim.value if decl.dim else ''
                    #print(decl.dim_quals)
                    #return ['ArrayDecl', dimval, decl.dim_quals, nested]
                    return ['ArrayDecl', dimval, nested]
                
            elif typ == PtrDecl:
                self.current_is_ptr = True
                return ['PtrDecl', nested]
            #elif typ == Struct:
                #self.has_struct_ref = True 
                #return ['Struct', nested]                    
            elif typ == Typedef:
                return ['Typedef', decl.name, nested]
            elif typ == FuncDecl:
                if decl.args:
                    self.current_args_params_func = decl.args.params
                    params = [self.expand_decl(param) for param in decl.args.params]
                else:
                    params = []
                return ['FuncDecl', params, nested]


    def expand_init(self, init):
        """
        Converts an initialization into a nested list
        """
        typ = type(init)

        #print("EX_pand_coord %s" % self.curr_has_operation_index_ptr)
        #print("EX_pand_coord %s" % init)
        #print("EX_pand %s" % typ)

        if typ == NamedInitializer:
            des = [self.expand_init(dp) for dp in init.name]
            return des, self.expand_init(init.expr)
        elif typ in (InitList, ExprList):
            return [self.expand_init(expr) for expr in init.exprs]
        elif typ == Constant:
            return ['Constant', init.type, init.value]
        elif typ == Cast:
            return ['Cast', init.expr, self.expand_init(init.expr)]
        elif typ == FuncCall:            
            self.has_call_func = True
            return ['FuncCall', init.name, self.expand_init(init.name)]
        elif typ == ID:
            self.current_Id_in_init = init.name            
            return ['ID', init.name]
        elif typ == Assignment:
            if type(init.rvalue) == Assignment:
                self.current_assignments.append(init.rvalue)
            return ['Assignment', self.expand_init(init.lvalue)]
        elif typ == UnaryOp:            
            return ['UnaryOp', init.op, self.expand_init(init.expr)]
        elif typ == ArrayRef:
            #self.curr_has_operation_index_ptr
            if self.tmp_flag_is_ptr:
                self.curr_has_operation_index_ptr = True
                self.curr_ptr_type_assig_arrRef = True
            #print("-------------------",init.name)
            return ['ArrayRef', init.name, self.expand_init(init.name)]
        elif typ == BinaryOp:
            if self.tmp_flag_is_ptr:
                self.curr_has_operation_index_ptr = True
                self.curr_ptr_type_assig_binOp = True
            #print("-------------- BinaryOp %s" % self.ast_gen.CGenerator().visit_BinaryOp(init))
            return ['BinaryOp', init.left, self.expand_init(init.left)]
        elif typ == TernaryOp:
            if self.tmp_flag_is_ptr:                
                return ['TernaryOp', init.cond.name, self.expand_init(init.iftrue), self.expand_init(init.iffalse)]
        elif typ == StructRef:
            self.has_struct_ref = True
            self.curr_field_used_by_struct_ref = init.field
            #print(init.type,init.field.name)
            return ['StructRef', init.type, self.expand_init(init.name)]



    def reset_var_to_dic_type(self):
        self.dicT_type_name = ''
        self.dicT_is_pointer = False
        self.dicT_real_type = ''
        self.dicT_is_struct = False


    def searchTypedef(self):
        """
        @summary: Searching in the AST to typedef and then gathering the data about the new types (i.e., typedef used)
        @return: NO
        """
        for index in range(0,len(self.ast.ext)):
            if type(self.ast.ext[index]) == Typedef:
                self.reset_var_to_dic_type()
                self.expand_and_define_typedefs(self.ast.ext[index])
                self.dictionary_of_var_types[self.dicT_type_name] = [self.dicT_real_type,self.dicT_is_pointer,self.dicT_is_struct]

        # Now it is necessary to use these data to FIX the mapping about typedef
        #for key, value in self.dictionary_of_var_types.items():
        #    print("%s - %s" % (key, value))



    def expand_and_define_typedefs(self, data):
        """
        @summary: Create and set list with the data about the new type (i.e., typedef used)
        @param data: pycparser.c_ast.*
        @return: NO
        @todo:
            - Create a dictionary with the new types and its data

        """
        typ = type(data)
        
        

        if typ == Typedef:
            self.dicT_type_name = data.name
            return ['Typedef', data.name, self.expand_and_define_typedefs(data.type)]
        elif typ == Decl:
            if data.quals:
                return ['Decl', data.quals, data.name, self.expand_and_define_typedefs(data.type)]
            else:
                return ['Decl', data.name, self.expand_and_define_typedefs(data.type)]
        elif typ == ArrayDecl:
            return ['ArrayDecl', self.expand_and_define_typedefs(data.type)]
        elif typ == PtrDecl:
            self.dicT_is_pointer = True
            return ['PtrDecl', self.expand_and_define_typedefs(data.type)]
        elif typ == TypeDecl:
            return ['TypeDecl', data.declname, self.expand_and_define_typedefs(data.type)]
        elif typ == IdentifierType:
            self.dicT_real_type = data.names
            return ['IdentifierType', data.names]
        elif typ == Struct:
            self.dicT_is_struct = True
            #return [self.expand_and_define_typedefs(decl) for decl in data.decls]
            nested = []
            #print("==================",data.name)
            
            # TODO: Checkout possibles issues
            # if data.decls is not None:
            #     for decl in data.decls:
            #     #   print(decl)
            #         nested.append(self.expand_and_define_typedefs(decl))
                    
            return ['Struct',nested]






    def expand_flow_program(self, flowProg):
        """
        @summary: Converts the flow of the program, e.g., IF, WHILE, FOR into a nested list
        @param flowProg: pycparser.c_ast.compud.block_items
        @return: NO
        @todo:
            - If - OK
            - While - OK
            - DoWhile OK
            - For - OK
            - Switch,Case - OK

        """
        typ = type(flowProg)
        #print(typ)
        self.enable_else_flow = False
        self.has_assign_in_case = False

        if typ == If:
            #print("Is a IF in: "+ str(flowProg.coord))
            if flowProg.iftrue is not None:
                #print(flowProg.iftrue)
                self.current_flow_program_comp = flowProg.iftrue
            if flowProg.iffalse is not None:
                self.enable_else_flow = True
                self.current_else_flow_program = flowProg.iffalse
            return ['If', flowProg.iftrue, flowProg.iffalse]

        elif typ == While:            
            self.current_flow_program_comp = flowProg.stmt
            return ['While', flowProg.stmt]

        elif typ == For:
            self.current_flow_program_comp = flowProg.stmt
            return ['For', flowProg.stmt]

        elif typ == DoWhile:
            self.current_flow_program_comp = flowProg.stmt
            return ['DoWhile', flowProg.stmt]

        elif typ == Switch:
            #print(flowProg.stmt)
            self.current_flow_program_comp = flowProg.stmt
            return ['Switch', flowProg.stmt]

        elif typ == Case:
            #print(flowProg.stmts)
            #for stmt in flowProg.stmts:
                #if type(stmt) is Assignment:
                    #self.has_assign_in_case = True
                    #self.current_assig_case = stmt
                    #print("\t ==== %s %s" % (stmt, stmt.coord))
                    #self.identifyAssigment(stmt, nodeVar)
                    #sys.exit()
            self.current_flow_program_comp = flowProg.stmts
            #print(self.current_flow_program_comp)
            #print(flowProg.expr)
            return ['Case', flowProg.stmts]


    def sortListMapByNumLine(self):
        """
        @summary: Sort the nested list with the data gathered to map the program
        @return: None
        """
        self.map_master_list_result.sort(key=itemgetter(0))


    def createOverviewResult(self, isToPrintResult):
        # Generate one list for each item that has been mapped
        # ex. num line, var ...
        list_locs = []
        list_vars = []
        list_global = []
        list_is_dynamic = []
        list_is_free = []
        for list in self.map_master_list_result:
            list_locs.append(list[0])
            list_vars.append(list[1])
            list_global.append(list[2])
            list_is_dynamic.append(list[4])
            list_is_free.append(list[5])

        # Get how many LOC has been mapped
        tmp_locs = set(list_locs)
        tmp_vars = set(list_vars)


        # Set var to unit test
        # TODO: review this!!!!! $$$$$$$$$$$$$$
        self.utest_total_num_obj_mapped = len(self.map_master_list_result)
        self.utest_lines_mapped = list_locs
        self.utest_total_num_free = list_is_free.count(True)
        self.utest_total_num_malloc = list_is_dynamic.count(True)
        self.utest_total_num_global_var = len(set(list_global))


        if isToPrintResult:
            # Print the results
            print("%s" % ("-"*90))
            print("Overview Results:")
            print("%s" % ("-"*90))
            print("Total Number of objects mapped: %7s" % len(self.map_master_list_result))
            print()
            print("Number of Lines   mapped: %7s" % len(tmp_locs))
            print("Number of Malloc  mapped: %7s" % list_is_dynamic.count(True))
            print("Number of Free    mapped: %7s" % list_is_free.count(True))
            print("%s" % ("_"*90))
            print()
            print("\t \t Number of ocurrences by variable")
            for v in tmp_vars:
                #-> Malloc: %5s -> Free: %5s
                print("%10s -> Decl. or Assig.: %5s" % (v,list_vars.count(v)))
            print()
            print("Number of VARS    mapped: %7s" % len(tmp_vars))
            print("Number of GB VARS mapped: %7s" % list_global.count(True))
            print("%s" % ("_"*90))
            print("%s" % ("-"*90))




    def printMapResult(self, optionPrint):
        """
        @summary: Print the data gathered from C program
        @param optionPrint: Set the type of print the result.
            The option are: (0) - Debug Mode and (1) - CSV mode
        @return: None
        """

        # Debug MODE output
        if optionPrint == 0:
            print("%13s ;%14s ;%14s ;%14s ;%14s ;%14s ;%14s ;%19s ;" % ("LOC","Variable","Points to","Scope","Is Global","Is Dynamic","Is Free","Is a Union"))
            print("%s" % ("-"*140))
            for list in self.map_master_list_result:
                for element in list:
                    print("%12s ; " % element, end="")
                print()
            print("%s" % ("-"*140))
            print()
            print("Firsl Decl on top: ")
            # Generate auxiliary file with de first pointer Decl in each function
            print(self.listL_of_first_decl_in_func)

        # CSV MODE output
        elif optionPrint == 1:
            print("LOC;Variable;Points to;Scope;Is Global;Is Dynamic;Is Free;Is Union;Type Var;Is Arg Funct")
            for list in self.map_master_list_result:
                for index in range(0,len(list)):
                    # Here we already set the C pattern to True and False, i.e., 1 or 0
                    if list[index] is True:
                        print("1", end="")
                    elif list[index] is False:
                        print("0", end="")
                    else:
                        print("%s" % list[index], end="")

                    # skip to set ";" in the end of the line
                    if index < (len(list)-1):
                        print(";", end="")

                print()
            
            # Generate auxiliary file with de first pointer Decl in main function
            path_file_write = os.path.join(os.path.dirname(__file__), "../../../result_claims/aux_file_map_2_translator.csv")
            
            aux_file_map_2_translator = open(path_file_write, "w")
            aux_file_map_2_translator.write("LineNumDecl;VarName\n")
            text = ''
            for ind, value in enumerate(self.listL_of_first_decl_in_func):
                text += str(value)
                if ind <= len(self.listL_of_first_decl_in_func):
                    text += " ; "
            text += "\n"
            aux_file_map_2_translator.write(text)                
            aux_file_map_2_translator.close()
            #print(self.listL_of_first_decl_in_func)
                
        # CSV MODE output, but only the line number
        elif optionPrint == 2:
            for list in self.map_master_list_result:
                print(list[0])
            
        
        
        

    def getUTestTotalNumObjMapped(self):
        """
        @summary: Method that return the total number of objects mapped in the gathering
        @return self.utest_total_num_obj_mapped: the total number of objects mapped
        """
        return self.utest_total_num_obj_mapped


    def getUTestLinesMapped(self):
        """
        @summary: Method that return the lines gathered in the mapping
        @return self.utest_lines_mapped: a list with the lines gathered in the C program
        """
        return self.utest_lines_mapped


    def getUTestTotalNumFree(self):
        """
        @summary: Method that return the total number of call free in the C program
        @return self.utest_total_num_free: the total number of call free
        """
        return self.utest_total_num_free


    def getUTestTotalNumMalloc(self):
        """
        @summary: Method that return the total number of call malloc in the C program
        @return self.utest_total_num_malloc: the total number of call malloc
        """
        return self.utest_total_num_malloc


    def getUTestTotalNumGlobalVar(self):
        """
        @summary: Method that return the total number of global variables in the C program
        @return self.utest_total_num_global_var: the total number of global variables
        """
        return self.utest_total_num_global_var

