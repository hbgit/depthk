/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 58 "mutex_example.h"
typedef unsigned int mutex_ea_t;
#line 60 "mutex_example.h"
struct __anonstruct_mutex_spu_test_argv_t_6 {
   mutex_ea_t mutex_ea ;
   unsigned long long buf_ea ;
   char pad[112] ;
};
#line 60 "mutex_example.h"
typedef struct __anonstruct_mutex_spu_test_argv_t_6  __attribute__((__aligned__(128))) mutex_spu_test_argv_t;
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 203 "../spu_mfcio.h"
extern void mfc_put(void volatile   *ls , unsigned int ea , unsigned int size , unsigned int tag ,
                    unsigned int tid , unsigned int rid ) ;
#line 211
extern void mfc_get(void volatile   *ls , unsigned int ea , unsigned int size , unsigned int tag ,
                    unsigned int tid , unsigned int rid ) ;
#line 252
extern void mfc_write_tag_mask(unsigned int mask ) ;
#line 270
extern void mfc_read_tag_status_all() ;
#line 361
extern unsigned int __mfc_tag_reserve(void) ;
#line 48 "mutex_spu_example.c"
static mutex_spu_test_argv_t spu_argv  __attribute__((__aligned__(128)))  ;
#line 49 "mutex_spu_example.c"
static int volatile   lsbuf[512]  __attribute__((__aligned__(128)))  ;
#line 72
extern int ( /* missing proto */  mutex_lock)() ;
#line 75
extern int ( /* missing proto */  mutex_trylock)() ;
#line 104
extern int ( /* missing proto */  mutex_unlock)() ;
#line 51 "mutex_spu_example.c"
int spu_main(unsigned long long spuid  __attribute__((__unused__)) , unsigned long long argp ) 
{ int i ;
  unsigned int tag_id ;
  mutex_ea_t mutex ;
  unsigned int tmp ;
  int tmp___0 ;
  int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void volatile   *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  mutex_spu_test_argv_t *__cil_tmp15 ;
  char const   * __restrict  __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int volatile   *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void volatile   *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long long __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int volatile   *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void volatile   *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long long __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned int __cil_tmp41 ;

  {
  {
#line 62
  tmp = __mfc_tag_reserve();
#line 62
  tag_id = tmp & 31U;
#line 65
  __cil_tmp9 = 1 << tag_id;
#line 65
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 65
  mfc_write_tag_mask(__cil_tmp10);
#line 66
  __cil_tmp11 = (void *)(& spu_argv);
#line 66
  __cil_tmp12 = (void volatile   *)__cil_tmp11;
#line 66
  __cil_tmp13 = (unsigned int )argp;
#line 66
  __cil_tmp14 = (unsigned int )128UL;
#line 66
  mfc_get(__cil_tmp12, __cil_tmp13, __cil_tmp14, tag_id, 0U, 0U);
#line 67
  mfc_read_tag_status_all();
#line 70
  __cil_tmp15 = & spu_argv;
#line 70
  mutex = *((mutex_ea_t *)__cil_tmp15);
#line 71
  i = 0;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (i < 10) {

    } else {
#line 71
      goto while_break;
    }
    {
#line 72
    mutex_lock(mutex);
#line 75
    tmp___0 = mutex_trylock(mutex);
    }
#line 75
    if (tmp___0) {
      {
#line 76
      __cil_tmp16 = (char const   * __restrict  )"SPU incorrectly got the lock a second time - exiting!\n";
#line 76
      printf(__cil_tmp16);
      }
    } else {

    }
    {
#line 85
    __cil_tmp17 = tag_id + 1U;
#line 85
    __cil_tmp18 = 1 << __cil_tmp17;
#line 85
    __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 85
    mfc_write_tag_mask(__cil_tmp19);
#line 91
    __cil_tmp20 = 0 * 4UL;
#line 91
    __cil_tmp21 = (unsigned long )(lsbuf) + __cil_tmp20;
#line 91
    __cil_tmp22 = (int volatile   *)__cil_tmp21;
#line 91
    __cil_tmp23 = (void *)__cil_tmp22;
#line 91
    __cil_tmp24 = (void volatile   *)__cil_tmp23;
#line 91
    __cil_tmp25 = (unsigned long )(& spu_argv) + 8;
#line 91
    __cil_tmp26 = *((unsigned long long *)__cil_tmp25);
#line 91
    __cil_tmp27 = (unsigned int )__cil_tmp26;
#line 91
    __cil_tmp28 = 4UL * 512UL;
#line 91
    __cil_tmp29 = (unsigned int )__cil_tmp28;
#line 91
    mfc_get(__cil_tmp24, __cil_tmp27, __cil_tmp29, tag_id, 0U, 0U);
#line 92
    mfc_read_tag_status_all();
#line 100
    __cil_tmp30 = 1 << tag_id;
#line 100
    __cil_tmp31 = (unsigned int )__cil_tmp30;
#line 100
    mfc_write_tag_mask(__cil_tmp31);
#line 101
    __cil_tmp32 = 0 * 4UL;
#line 101
    __cil_tmp33 = (unsigned long )(lsbuf) + __cil_tmp32;
#line 101
    __cil_tmp34 = (int volatile   *)__cil_tmp33;
#line 101
    __cil_tmp35 = (void *)__cil_tmp34;
#line 101
    __cil_tmp36 = (void volatile   *)__cil_tmp35;
#line 101
    __cil_tmp37 = (unsigned long )(& spu_argv) + 8;
#line 101
    __cil_tmp38 = *((unsigned long long *)__cil_tmp37);
#line 101
    __cil_tmp39 = (unsigned int )__cil_tmp38;
#line 101
    __cil_tmp40 = 4UL * 512UL;
#line 101
    __cil_tmp41 = (unsigned int )__cil_tmp40;
#line 101
    mfc_put(__cil_tmp36, __cil_tmp39, __cil_tmp41, tag_id, 0U, 0U);
#line 102
    mfc_read_tag_status_all();
#line 104
    mutex_unlock(mutex);
#line 71
    i = i + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
